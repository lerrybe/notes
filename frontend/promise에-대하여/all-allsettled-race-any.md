# Promise 함수들: Promise.all, Promise.allSettled 등 비교 및 특징

- JavaScript에서 비동기 작업을 처리하기 위해 `Promise` 객체를 활용함.
- 여러 개의 프로미스를 동시에 처리하거나 그 결과를 집계해야 할 때 다양한 메서드를 사용할 수 있음.
- 여기서는 `Promise.all`, `Promise.allSettled`, `Promise.race`, `Promise.any` 등 주요 프로미스 함수를 비교하고, 각 함수의 특징, 사용 시기, 사이드 이펙트, 장단점 등에 대해 알아봄.

## 1. Promise.all

### 특징

- **입력된 모든 프로미스가 이행(fulfilled)될 때까지 기다림.**
- **하나의 프로미스라도 거부(rejected)되면 즉시 거부됨.**
- **이행 시 모든 결과를 배열로 반환함.**

### 사용 시기

- 여러 비동기 작업이 **모두 성공해야** 다음 작업을 진행할 수 있는 경우.
- 병렬로 실행되는 작업들의 결과를 모두 사용할 때.

### 장점

- **효율성**: 비동기 작업을 병렬로 실행하여 전체 처리 시간을 단축할 수 있음.
- **단순성**: 모든 작업이 성공해야 하는 경우 로직이 간단함.

### 단점

- **에러 처리의 어려움**: 하나의 프로미스라도 거부되면 전체가 거부되므로, 어떤 프로미스가 실패했는지 파악하기 어려움.
- **부분 성공 처리 불가**: 일부 작업이 실패해도 성공한 작업의 결과를 활용해야 하는 경우 적합하지 않음.

### 사이드 이펙트

- **즉시 거부**: 하나의 프로미스가 거부되면 나머지 프로미스의 결과를 기다리지 않고 거부됨. 하지만 이미 실행된 프로미스는 계속 진행됨.

### 예제

```javascript
Promise.all([promise1, promise2, promise3])
  .then(results => {
    // 모든 프로미스가 성공한 경우
  })
  .catch(error => {
    // 하나라도 실패한 경우
  });
```

## 2. Promise.allSettled

### 특징

- **입력된 모든 프로미스가 완료(settled)될 때까지 기다림.**
- **프로미스의 이행 여부와 관계없이 모든 결과를 반환함.**
- **각 프로미스의 상태(`fulfilled` 또는 `rejected`)와 결과를 포함한 객체 배열을 반환함.**

### 사용 시기

- 여러 비동기 작업의 **개별 결과**에 관심이 있을 때.
- 일부 작업이 실패해도 전체 작업을 완료하고, 각 작업의 성공 또는 실패를 처리해야 할 때.

### 장점

- **포괄적인 결과 처리**: 모든 프로미스의 결과를 수집하여 개별적으로 처리 가능.
- **에러 격리**: 하나의 프로미스 실패가 다른 프로미스의 결과 수집에 영향 주지 않음.

### 단점

- **복잡성 증가**: 반환된 결과 배열을 순회하며 각 프로미스의 상태를 확인하고 처리해야 함.
- **실패한 프로미스에 대한 추가 처리 필요**: 에러 핸들링 로직을 별도로 구현해야 함.

### 사이드 이펙트

- **모든 프로미스 실행**: 모든 프로미스가 완료될 때까지 기다리므로, 불필요한 작업이 실행될 수 있음.

### 예제

```javascript
Promise.allSettled([promise1, promise2, promise3]).then(results => {
  results.forEach(result => {
    if (result.status === "fulfilled") {
      // 성공한 경우 처리
    } else {
      // 실패한 경우 처리
    }
  });
});
```

## 3. Promise.race

### 특징

- **가장 먼저 완료된(이행 또는 거부된) 프로미스의 결과를 반환함.**
- **첫 번째 완료된 프로미스의 결과에 따라 이행 또는 거부됨.**

### 사용 시기

- 여러 비동기 작업 중 **가장 빠른 응답**을 필요로 할 때.
- **타임아웃 구현**: 일정 시간 내에 응답이 없을 경우 에러를 발생시키고자 할 때.

### 장점

- **빠른 응답 획득**: 가장 빨리 완료되는 프로미스의 결과를 즉시 사용할 수 있음.

### 단점

- **나머지 프로미스 무시**: 다른 프로미스의 결과를 무시하므로, 필요한 경우 별도로 처리해야 함.
- **에러 처리의 어려움**: 거부된 프로미스가 먼저 완료되면 전체가 거부됨.

### 사이드 이펙트

- **나머지 프로미스 실행 지속**: 첫 번째 프로미스가 완료되어도 나머지 프로미스는 계속 실행됨.

### 예제

```javascript
Promise.race([promise1, promise2, promise3])
  .then(result => {
    // 가장 먼저 완료된 프로미스의 결과
  })
  .catch(error => {
    // 가장 먼저 거부된 프로미스의 에러
  });
```

## 4. Promise.any

### 특징

- **입력된 프로미스 중 하나라도 이행되면 즉시 이행됨.**
- **모든 프로미스가 거부되면 AggregateError를 발생시킴.**

### 사용 시기

- 여러 비동기 작업 중 **하나라도 성공하면** 다음 작업을 진행할 수 있는 경우.
- 다수의 대체 가능한 비동기 작업이 있을 때.

### 장점

- **높은 가용성**: 여러 옵션 중 하나만 성공하면 되므로, 장애 대응력이 높음.

### 단점

- **에러 처리 복잡성**: 모든 프로미스가 실패한 경우 에러 처리가 필요함.
- **거부된 프로미스의 에러 수집 어려움**: AggregateError로 묶여서 반환되므로 개별 에러 처리가 복잡함.

### 사이드 이펙트

- **나머지 프로미스 실행 지속**: 하나의 프로미스가 이행되어도 나머지 프로미스는 계속 실행됨.

### 예제

```javascript
Promise.any([promise1, promise2, promise3])
  .then(result => {
    // 하나의 프로미스가 성공한 결과
  })
  .catch(error => {
    // 모든 프로미스가 실패한 경우
  });
```

## 비교 요약

| 함수                   | 이행 조건                                       | 거부 조건                                           | 주요 사용 시기                                     |
| ---------------------- | ----------------------------------------------- | --------------------------------------------------- | -------------------------------------------------- |
| **Promise.all**        | 모든 프로미스가 이행되면 이행                   | 하나라도 거부되면 즉시 거부                         | 모든 작업이 성공해야 하는 경우                     |
| **Promise.allSettled** | 모든 프로미스가 완료되면 이행                   | 거부되지 않음 (모든 결과를 반환)                    | 각 작업의 성공/실패 여부를 모두 처리해야 하는 경우 |
| **Promise.race**       | 가장 먼저 완료된 프로미스에 따라 이행 또는 거부 | 첫 번째 완료된 프로미스의 상태에 따름               | 가장 빠른 응답이 필요한 경우                       |
| **Promise.any**        | 하나의 프로미스가 이행되면 이행                 | 모든 프로미스가 거부되면 거부 (AggregateError 발생) | 하나라도 성공하면 되는 경우                        |

## 언제 어떤 함수를 사용해야 할까?

- **Promise.all**

  - 모든 비동기 작업이 성공해야 다음 단계로 진행할 수 있을 때
  - 병렬로 실행되는 작업들의 결과를 모두 사용할 때
  - 예: 여러 API 호출 결과를 조합해야 하는 경우

- **Promise.allSettled**

  - 각 비동기 작업의 성공 여부와 관계없이 결과를 수집해야 할 때
  - 일부 작업이 실패해도 전체 결과를 처리해야 하는 경우
  - 예: 여러 파일 업로드 결과를 개별적으로 처리해야 하는 경우

- **Promise.race**

  - 여러 작업 중 가장 빠른 결과에 따라 로직을 진행해야 할 때
  - 타임아웃 또는 첫 번째 응답을 우선시해야 하는 경우
  - 예: 네트워크 요청의 타임아웃 구현

- **Promise.any**
  - 여러 작업 중 하나라도 성공하면 되는 경우
  - 다수의 대체 가능한 작업 중 하나만 성공해도 충분할 때
  - 예: 여러 캐시 서버 중 하나에서 데이터를 가져올 때

## 사이드 이펙트 및 고려사항

- **실행 중인 프로미스 취소 불가**

  - JavaScript의 프로미스는 실행 중인 작업을 취소할 수 없음. 따라서 필요 없는 작업이라도 계속 실행됨.
  - 불필요한 리소스 소비를 막기 위해서는 별도의 취소 로직을 작성해야 함.

- **에러 핸들링의 복잡성**

  - 일부 프로미스 함수는 에러 처리가 복잡해질 수 있음. 특히 `Promise.all`의 경우 어떤 프로미스가 실패했는지 확인하기 어려움.
  - 에러 처리를 체계적으로 설계해야 함.

- **메모리 누수 가능성**
  - 많은 수의 프로미스를 생성하고 관리할 때 메모리 누수가 발생할 수 있음.
  - 프로미스 배열을 관리할 때 주의해야 함.

## 결론

비동기 작업을 효과적으로 관리하기 위해서는 상황에 맞는 프로미스 함수를 선택해야 함.

- 모든 작업이 성공해야 한다면 `Promise.all`.
- 각 작업의 결과에 관심이 있다면 `Promise.allSettled`.
- 가장 빠른 응답을 원한다면 `Promise.race`.
- 하나라도 성공하면 되는 경우 `Promise.any`.

사이드 이펙트을 고려하여 적절한 방법을 선택하면 효율적이고 안정적인 비동기 코드를 작성할 수 있겠다.

## Reference

- [MDN Promise](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise)
