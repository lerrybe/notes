## 런타임 성능 체크 시 확인해야 할 주요 지표

### 1. **페이지 로드 시간**

- **Time to First Byte (TTFB)**: 서버로부터 첫 번째 바이트를 받기까지의 시간. 서버 응답 속도를 나타내며, 네트워크 지연이나 서버 처리 시간이 영향을 미침.
- **First Contentful Paint (FCP)**: 화면에 첫 번째 콘텐츠(텍스트, 이미지 등)가 렌더링되는 시간. 사용자는 이 시점부터 페이지 로딩이 시작되었다고 인식함.
- **Largest Contentful Paint (LCP)**: 가장 큰 콘텐츠 요소(주로 히어로 이미지나 큰 텍스트 블록)가 렌더링되는 시간. 사용자에게 페이지의 주요 콘텐츠가 보이는 시점.
- **Time to Interactive (TTI)**: 페이지가 완전히 상호작용 가능해지는 시간. 이 시점 이후에는 사용자의 입력에 즉시 반응할 수 있음.

### 2. **JavaScript 실행 시간**

- **파싱 및 컴파일 시간**: JavaScript 코드를 파싱하고 컴파일하는 데 걸리는 시간.
- **실행 시간**: 함수 호출, 이벤트 핸들러 등이 실행되는 시간. 복잡한 연산이나 대량의 데이터 처리가 영향을 미침.

### 3. **렌더링 성능**

- **레이아웃 (Layout)**: 요소의 위치와 크기를 계산하는 데 걸리는 시간. DOM 변경이 빈번하면 레이아웃 계산이 자주 발생함.
- **페인트 (Paint)**: 요소를 그리는 데 걸리는 시간. 스타일 변경이나 새로운 요소 추가가 영향을 줌.
- **합성 (Composite)**: 여러 레이어를 결합하여 최종 화면을 만드는 과정.

### 4. **메모리 사용량**

- **메모리 누수**: 사용되지 않는 메모리가 해제되지 않아 누적되는 현상
- **가비지 컬렉션 효율성**: 불필요한 메모리를 얼마나 효과적으로 회수하는지 나타냄.

### 5. **네트워크 성능**

- **요청 수**: 페이지 로드 시 필요한 HTTP 요청의 수
- **응답 크기**: 각 요청에 대한 응답 데이터의 크기
- **캐싱 및 압축**: 리소스의 캐싱 여부와 압축 사용은 네트워크 성능에 직접적인 영향을 줌.

### 6. **CPU 사용량**

- **스크립트 실행 부하**: 복잡한 스크립트는 CPU 사용량을 증가시킴.
- **애니메이션**: 부드러운 애니메이션을 위해서는 고성능의 CPU 처리가 필요함.

### 7. **프레임 레이트 (FPS)**

- **애니메이션과 스크롤 부드러움**: 이상적인 프레임 레이트는 60FPS이며, 이는 부드러운 사용자 경험을 제공함.
- **드롭된 프레임**: 프레임 레이트가 떨어지면 화면이 끊겨 보임.

### 8. **반응성**

- **First Input Delay (FID)**: 사용자의 첫 입력에 반응하기까지의 지연 시간
- **총 차단 시간 (Total Blocking Time, TBT)**: 메인 스레드가 차단되어 사용자 입력에 반응하지 못하는 시간의 총합

## 런타임 성능에 영향을 주는 요소들

### 1. **코드의 복잡성**

- **불필요한 연산**: 반복문 내에서의 복잡한 계산이나 DOM 조작은 성능 저하를 유발
- **비효율적인 알고리즘**: 최적화되지 않은 알고리즘은 실행 시간을 늘림.

### 2. **DOM 조작 빈도**

- **잦은 DOM 업데이트**: DOM을 자주 변경하면 레이아웃과 페인트가 반복적으로 발생
- **대량의 DOM 요소**: 너무 많은 요소를 한꺼번에 추가하거나 변경하면 렌더링 시간이 증가

### 3. **이미지 및 미디어 리소스**

- **고해상도 이미지**: 용량이 큰 이미지는 로드 시간과 메모리 사용량을 증가시킴.
- **미압축 이미지**: 압축되지 않은 이미지는 네트워크 대역폭을 많이 차지함.

### 4. **네트워크 지연**

- **서버 응답 시간**: 서버의 처리 속도가 느리면 TTFB가 증가함.
- **리소스 로드 순서**: 중요한 리소스가 늦게 로드되면 페이지의 주요 기능이 지연됨.

### 5. **블로킹 리소스**

- **렌더링 차단 스크립트**: `<script>` 태그에 `async`나 `defer`를 사용하지 않으면 HTML 파싱이 중단됨.
- **CSS 전처리**: 복잡한 CSS는 렌더링을 지연시킬 수 있음.

### 6. **메모리 누수**

- **이벤트 리스너 미해제**: 페이지에서 제거된 요소에 대한 이벤트 리스너를 해제하지 않으면 메모리 누수가 발생함.
- **전역 변수 남용**: 전역 스코프에 변수를 많이 선언하면 가비지 컬렉션이 어려워짐.

### 7. **외부 라이브러리 사용**

- **과도한 라이브러리**: 필요한 기능보다 더 많은 기능을 가진 큰 라이브러리를 사용하면 불필요한 코드가 로드됨.
- **라이브러리 버전 관리**: 오래된 버전은 성능 최적화가 덜 되어 있을 수 있음.

## 성능 최적화를 위한 베스트 프랙티스

- **코드 스플리팅**
  - 필요한 부분만 로드하여 초기 로드 시간을 줄임.
- **이미지 최적화**
  - 이미지 압축 및 적절한 포맷(Webp 등) 사용으로 용량을 줄임.
- **캐싱 전략 수립**
  - 브라우저 캐시와 CDN을 활용하여 네트워크 요청을 최소화함. (단, 캐싱의 경우 적절한 타이밍에 invalidation을 해줘야 outdated된 데이터를 보는 것을 막을 수 있으니 주의)
- **비동기 로딩**
  - 스크립트와 스타일시트를 비동기로 로드하여 렌더링 차단을 방지함.
- **Reflow 최소화**
  - CSS 변경을 최소화하고, DOM 조작은 한 번에 수행함.
- **사용자 입력 처리 최적화**
  - 이벤트 핸들러에서의 복잡한 연산을 피하고, 필요한 경우 `requestAnimationFrame`이나 `setTimeout`을 활용함. (메인 스레드의 부하를 줄이기 위해 작업을 비동기적으로 처리하기 위함)
- **Web worker 활용**
  - 복잡한 연산이나 대용량 데이터 처리를 웹 워커로 분리하면 메인 스레드의 부하를 줄일 수 있음. 다만, 웹 워커는 별도의 스레드에서 동작하므로 DOM에 직접 접근할 수 없음. 따라서 메인 스레드와의 데이터 통신이 필요함
