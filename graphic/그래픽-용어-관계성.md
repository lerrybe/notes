## 1. 기본 개념 이해

### Canvas 태그 (HTML Canvas)

- **정의**: HTML `<canvas>` 태그는 웹 페이지에서 비트맵 그래픽을 그리기 위한 영역을 제공
- **용도**: 2D 그래픽, 게임, 데이터 시각화, 애니메이션 등을 구현하는 데 사용
- **렌더링 컨텍스트**: `2d`와 `webgl` 두 가지 주요 컨텍스트를 제공

### WebGL

- **정의**: WebGL(Web Graphics Library)은 웹에서 고성능 3D 및 2D 그래픽을 렌더링하기 위한 JavaScript API
- **기반**: OpenGL ES(Embedded Systems)의 표준을 따름
- **GPU 활용**: 주로 GPU를 활용하여 복잡한 그래픽을 효율적으로 처리

### OffscreenCanvas

- **정의**: OffscreenCanvas는 메인 스레드와 별도로 캔버스 그래픽을 렌더링할 수 있는 기능을 제공
- **용도**: 웹 워커(Web Workers)와 함께 사용되어 메인 스레드의 부하를 줄이고, 성능을 향상
- **렌더링**: 2D 및 WebGL 컨텍스트를 지원

### Web Worker

- **정의**: Web Worker는 메인 스레드와 별도로 실행되는 스크립트로, 병렬 처리를 가능하게 함
- **용도**: 무거운 연산이나 백그라운드 작업을 처리하여 UI의 반응성을 유지

### CPU와 GPU

- **CPU (Central Processing Unit)**: 일반적인 연산과 논리 처리를 담당, 웹 애플리케이션의 대부분의 로직을 처리
- **GPU (Graphics Processing Unit)**: 병렬 처리가 가능한 그래픽 및 수치 연산에 특화된 프로세서로, 복잡한 그래픽 렌더링을 효율적으로 수행

## 2. 동작 및 관계성

### 메인 스레드와 워커 스레드

- **메인 스레드**: 브라우저의 UI 렌더링, 사용자 입력 처리, DOM 조작 등을 담당
- **Web Worker**: 메인 스레드와 별도로 동작하여 데이터 처리, 계산 등 무거운 작업을 수행, OffscreenCanvas를 사용하면 Web Worker에서 직접 캔버스를 렌더링할 수 있음

### CPU와 GPU의 역할 분담

- **CPU**: 주로 JavaScript 코드 실행, 이벤트 처리, 로직 연산 등을 담당
- **GPU**: 그래픽 연산, 텍스처 처리, 셰이더 실행 등을 담당하여 그래픽 렌더링 성능을 향상

### Canvas, WebGL, OffscreenCanvas의 활용

- **Canvas 2D**: 단순한 2D 그래픽을 그리는 데 적합하며, CPU에서 주로 처리
- **WebGL**: 복잡한 3D 및 고성능 2D 그래픽을 렌더링할 때 사용되며, GPU의 병렬 처리 능력을 활용
- **OffscreenCanvas**: 메인 스레드 외부에서 캔버스 렌더링을 수행할 수 있어, Web Worker와 결합하여 성능을 최적화. 예를 들어, 그래픽 렌더링을 워커에서 처리하고, 메인 스레드는 UI와 사용자 입력을 담당할 수 있음

## 3. 구체적인 동작 예시

### OffscreenCanvas와 Web Worker의 결합

1. **메인 스레드**: OffscreenCanvas 객체를 생성하고, 이를 Web Worker로 전달
2. **Web Worker**: 전달받은 OffscreenCanvas를 사용하여 2D 또는 WebGL 컨텍스트를 초기화하고, 그래픽을 렌더링
3. **렌더링 결과**: OffscreenCanvas는 메인 스레드의 `<canvas>` 태그와 연결되어, 렌더링된 그래픽을 화면에 표시
4. **장점**: 메인 스레드의 부하를 줄이고, 그래픽 렌더링과 UI 처리를 병렬로 수행할 수 있어 성능이 향상

## 4. 성능 최적화 전략

### GPU 활용

- **WebGL 사용**: 가능하면 WebGL을 사용하여 GPU의 병렬 처리 능력을 최대한 활용, PixiJS와 같은 라이브러리가 이를 쉽게 도와줌
- **텍스처 최적화**: 텍스처 크기를 최적화하고, 필요한 경우 압축된 포맷을 사용하여 GPU 메모리 사용을 줄임

### CPU 부하 분산

- **Web Worker 사용**: 무거운 계산 작업이나 데이터 처리를 Web Worker로 이전하여 메인 스레드의 부하를 줄임
- **OffscreenCanvas 활용**: Web Worker에서 OffscreenCanvas를 사용하여 캔버스 렌더링을 분리함으로써 CPU와 GPU의 효율을 높임

### 렌더링 효율화

- **배치 렌더링**: 가능한 한 많은 그래픽 요소를 한 번에 렌더링하여 드로우 콜(draw call)의 수를 줄임
- **최적화된 도형 사용**: 불필요한 복잡한 도형 대신 간단한 도형을 사용하거나, 필요한 경우 셰이더를 최적화하여 렌더링 성능을 향상시킴

## 5. 메모리 관점에서의 동작

웹 애플리케이션의 성능 최적화는 CPU와 GPU의 효율적인 활용뿐만 아니라 메모리 관리에도 크게 의존한다. 각 기술이 메모리를 어떻게 사용하고 관리하는지 이해하는 것은 고성능 그래픽과 원활한 사용자 경험을 제공하는 데 필수적

### 5.1. Canvas 태그와 메모리

#### 5.1.1. Canvas 2D

- **비트맵 데이터**: Canvas 2D는 픽셀 단위의 비트맵 데이터를 메모리에 저장한다. 이 데이터는 `ImageData` 객체로 접근할 수 있으며, 각 픽셀의 RGBA 값을 포함함.
- **메모리 사용량**: 캔버스의 크기(width × height × 4 bytes)와 프레임 수에 따라 메모리 사용량이 결정됨. 큰 캔버스나 고해상도 캔버스를 사용할수록 메모리 사용량이 증가
- **메모리 관리**: 불필요한 `ImageData` 객체의 생성을 피하고, 캔버스 크기를 적절히 조절하여 메모리 사용을 최적화해야함

#### 5.1.2. WebGL

- **버퍼 오브젝트**: WebGL은 정점 데이터, 인덱스 데이터, 텍스처 등 다양한 데이터를 GPU 메모리에 저장함. 이들은 버퍼 오브젝트(Vertex Buffer Objects, VBOs)로 관리됨
- **텍스처 메모리**: 텍스처는 GPU 메모리에 저장되며, 텍스처의 해상도와 포맷에 따라 메모리 사용량이 결정됨. 고해상도 텍스처는 더 많은 메모리를 소비
- **셰이더 프로그램**: 셰이더 코드와 관련 데이터는 GPU 메모리에 로드. 복잡한 셰이더는 더 많은 메모리를 요구할 수 있음
- **메모리 관리**: WebGL에서는 `gl.deleteBuffer`, `gl.deleteTexture` 등을 사용하여 불필요한 GPU 메모리를 해제해야 함. 메모리 누수를 방지하기 위해 자원을 적절히 관리하는 것이 중요

### 5.2. OffscreenCanvas와 Web Worker의 메모리 관리

#### 5.2.1. OffscreenCanvas

- **메인 스레드와의 분리**: OffscreenCanvas는 메인 스레드와 별도로 메모리를 사용하여 캔버스 데이터를 처리함. 이를 통해 메인 스레드의 메모리 부하를 줄일 수 있음
- **메모리 할당**: OffscreenCanvas는 Web Worker 내에서 별도의 메모리 공간을 할당받아 렌더링 작업을 수행함. 이로 인해 메인 스레드와의 메모리 충돌을 최소화할 수 있음
- **데이터 전송**: OffscreenCanvas를 Web Worker로 전송할 때는 포스트 메시지 방식이 사용되며, Transferable 객체를 통해 소유권이 이전되어 메모리 복사를 최소화함

#### 5.2.2. Web Worker

- **독립된 메모리 공간**: Web Worker는 메인 스레드와 독립된 메모리 공간을 가지므로, 메모리 사용이 분리됨. 이는 메모리 충돌을 방지하고, 병렬 처리를 통해 성능을 향상시킵니다.
- **데이터 전송 비용**: 메인 스레드와 Web Worker 간의 데이터 전송은 메모리 복사 비용이 발생할 수 있음. 이를 줄이기 위해 Transferable 객체를 사용하여 소유권을 이전하는 것이 효과적.
- **메모리 관리**: Web Worker 내에서 생성된 객체나 데이터는 워커가 종료될 때 자동으로 해제됨. 그러나 워커가 장기간 실행되는 경우, 명시적으로 자원을 해제하는 것이 메모리 누수를 방지할 수 있음.

### 5.3. CPU와 GPU의 메모리 사용

#### 5.3.1. CPU 메모리

- **메인 메모리(RAM)**: CPU는 주로 시스템의 주 메모리(RAM)를 사용하여 데이터를 처리. JavaScript 객체, 배열, 함수 등이 이곳에 저장된다.
- **캐시 메모리**: CPU 내부의 캐시 메모리는 자주 접근하는 데이터를 저장하여 속도를 향상시킴. 효율적인 메모리 접근 패턴은 캐시 히트를 증가시켜 성능을 향상
- **메모리 관리**: JavaScript의 가비지 컬렉션(Garbage Collection)은 사용되지 않는 객체를 자동으로 해제하지만, 불필요한 객체 생성을 줄이고 참조를 적절히 관리하여 메모리 사용을 최적화할 수 있음.

#### 5.3.2. GPU 메모리

- **전용 비디오 메모리(VRAM)**: GPU는 전용 비디오 메모리(VRAM)를 사용하여 텍스처, 버퍼, 셰이더 등을 저장함. VRAM의 용량과 속도는 그래픽 성능에 직접적인 영향을 미칠 수 있음
- **데이터 전송**: CPU에서 GPU로의 데이터 전송은 메인 메모리와 GPU 메모리 간의 대역폭에 의존. 효율적인 데이터 전송은 성능과 메모리 사용에 영향을 미침
- **메모리 관리**: WebGL API를 통해 GPU 메모리에 로드된 리소스는 명시적으로 해제해야 함. `gl.deleteTexture`, `gl.deleteBuffer` 등을 사용하여 불필요한 리소스를 제거해야 메모리 누수를 방지할 수 있음.

### 5.4. 메모리 최적화 전략

#### 5.4.1. 데이터 구조 최적화

- **효율적인 데이터 구조 사용**: 배열, 객체 등의 데이터 구조를 효율적으로 사용하여 메모리 사용을 최소화한다. 예를 들어, 고정된 크기의 배열을 사용하거나, 필요한 데이터만 저장하자
- **메모리 재사용**: 객체 풀(Object Pool)을 사용하여 객체를 재사용함으로써 메모리 할당과 해제의 비용을 줄이고, 메모리 단편화를 방지할 수 있음.

#### 5.4.2. 리소스 관리

- **동적 로딩**: 필요할 때만 리소스를 로드하고, 사용이 끝난 리소스는 즉시 해제하여 메모리 사용을 최적화하자
- **텍스처 압축**: 텍스처를 압축된 포맷으로 저장하여 GPU 메모리 사용을 줄일 수 있음. WebGL에서는 압축된 텍스처 포맷을 지원하므로 이를 활용할 수 있음.

#### 5.4.3. 메모리 누수 방지

- **참조 관리**: 불필요한 참조를 제거하여 가비지 컬렉션이 제대로 작동하도록 할 수 있다. 클로저나 이벤트 리스너로 인한 참조 누수를 주의해야 함
- **자원 해제**: WebGL 리소스, OffscreenCanvas, Web Worker 등의 자원을 사용 후 명시적으로 해제하여 메모리 누수를 방지함.

#### 5.4.4. 프로파일링 및 모니터링

- **브라우저 개발자 도구**: Chrome DevTools, Firefox Developer Tools 등 브라우저의 개발자 도구를 사용하여 메모리 사용량을 모니터링하고, 메모리 누수를 감지할 수 있음.
- **프로파일링 도구**: WebGL 및 JavaScript 코드의 메모리 사용을 분석하고 최적화할 수 있는 다양한 프로파일링 도구를 활용.

## 6. 종합 요약

### 6.1. 기술별 메모리 사용 요약

- **Canvas 2D**: 비트맵 데이터를 메모리에 저장하며, 캔버스 크기와 해상도에 따라 메모리 사용량이 증가.
- **WebGL**: 정점 데이터, 텍스처, 셰이더 등을 GPU 메모리에 저장하며, 고해상도 텍스처와 복잡한 셰이더는 더 많은 메모리를 요구함
- **OffscreenCanvas**: Web Worker 내에서 별도의 메모리 공간을 사용하여 캔버스 데이터를 처리하며, Transferable 객체를 통해 효율적으로 데이터를 전송
- **Web Worker**: 독립된 메모리 공간을 사용하여 병렬 처리를 수행하며, 데이터 전송 시 메모리 복사 비용을 최소화하는 것이 중요
- **CPU와 GPU**: CPU는 주 메모리(RAM)를 사용하여 일반 연산과 로직을 처리하고, GPU는 전용 비디오 메모리(VRAM)를 사용하여 그래픽 연산을 수행함
