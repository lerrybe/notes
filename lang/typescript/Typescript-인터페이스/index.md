# TypeScript 인터페이스

...를 알아볼건데, 궁금한 지점을 위주로 의식의 흐름을 따라가며 살펴봅니다.

## TSC가 (타입스크립트 컴파일러)가 소스코드를 처리하는 흐름

- 기본적으로 타입스크립트 컴파일러가 어떤 식으로 문자열들을 처리하는지 봅니다.

1. **스캐너(Scanner, Lexer)**
   - 소스 코드를 **문자 단위**로 읽어서 “토큰(token)” 리스트로 쪼개고, 유효한 토큰을 발행 (예: `interface Obj { name: string; }` -> `interface`, `Obj`, `{`, `name`, `:`, `string`, `;`, `}`, ...)
2. **파서(Parser)**
   - 만들어진 토큰들을 기반으로 **구문 트리**(Syntax Tree), 보통 **AST(Abstract Syntax Tree)**를 구성 (예를 들어 `interface Obj { ... }`라는 구문을 만났을 때, 파서는 “이것은 `InterfaceDeclaration`이구나” 하고 AST 노드를 만들고, 그 아래에 ‘멤버들(member들)을 담는 노드들’을 하위 노드로 추가)
3. **바인더(Binder)**
   - AST를 순회하며 **선언부(Declaration)**를 수집하고, **심볼(Symbol)** 테이블을 구성. 인터페이스의 이름이나, 인터페이스 안에 선언된 멤버같은 것들이 해당 심볼 테이블에 들어감
4. **체커(Checker, Type Checker)**
   - 심볼 테이블과 AST를 분석하여 **타입 정보**를 확인, 추론, 검증
   - `interface Obj { name: string; ... }` 라면, `Obj`라는 타입이 “이름이 문자열이고, 나이가 숫자이고, greet라는 메서드가 있는 **객체 모양**”이라고 체커가 인식. 이 과정에서, 코드를 사용하는(사용자 측에서 작성된) 문맥과 비교해 **타입에 맞게 써졌는지**를 검사
5. **트랜스파일(Transpile, Emitter)**
   - 타입 체크를 마친 후 최종적으로 **JavaScript 코드**를 생성. `interface`같은 타입 선언은 런타임에 필요 없으므로 **실제 출력 JS에는 등장하지 않음.** 순수히 컴파일 타임에만 존재하고, 타입 정보만 담당하므로 “shape” 정의용으로만 쓰임

## 1. TypeScript에서의 인터페이스

```tsx
interface Obj {
  // 오로지 타입(형태)만 정의
  name: string;
  age: number;
  greet(message: string): void;
}
```

- **인터페이스는 private, protected 키워드를 지원하지 않는다.**

  - 인터페이스는 객체의 **모습** (shape)만 정의하기 때문에, 접근 제한자(Access Modifier) 같은 구체적인 제어 권한은 설정할 수 없음
  - 인터페이스는 클래스와 달리 런타임에 실제로 구현되는 코드를 포함하지 않고, 오직 객체가 가져야하는 속성과 메서드의 모양을 정의하는 타입수준(type-level)의 개념. (런타임에 사라진다.) **_아예 컴파일 결과물에 나타나지 않음_**
  - 접근 제어자는 (private, protected 등) 클래스 멤버가 외부로부터 어떻게 접근 가능한지 제어하는 키워드로, 구현체 내에서 의미가 있는 속성들임. 따라서 인터페이스가 private나 protected를 지원한다고 하더라도, 실제로 런타임에서 접근 제한 로직을 구현할 수 있는 방법이 없다. 결국 구체적 제어권을 넣는게 의미없는 문법이라 TS에도 지원 안하는듯. 이런 이유에서 private, protected를 인터페이스 문법에서 지원할 이유가 없고, 지원한다 하더라도 런타임에 반영할 방법이 없음
  - 반면 클래스는 런타임 객체를 생성하고, 거기에 실제 필드와 메서드들이 들어감 (구현체들) TypeScript의 클래스 컴파일 결과물도 결국 JS 클래스(class)나 프로토타입 기반 코드로 변환되는데, 최신 JS(ES2022~)는 `#privateField` 같은 사양이 있음.
  - 물론 TS 클래스에서 private/protected같은 접근 제어자를 쓴다고 해도, 실제로 TypeScript의 `private` / `protected`는 **주로 컴파일 타임**(type-level)에서만 사용이 강제(에러 검출)되고, 최종 출력된 JS 코드에서 완벽한 진짜 은닉(Encapsulation)이 되는 것은 아니긴 함. 그럼 여기서 **_“인터페이스처럼 클래스 멤버의 접근제어자도 의미없는거 아니냐?”_** 라고 물을 수 있음
    - 또한 최신 ECMAScript에서는 (**ES2022**(혹은 Stage 3~4) 이후로)JavaScript 자체가 **진짜 `#private` 필드**를 지원)
    - TypeScript도 `useDefineForClassFields` 설정이나 최신 타깃(`target: "ESNext"`)을 사용하면, 실제로 런타임 레벨에서 트랜스파일 후 private 필드가 만들어짐, 런타임 시점에 해당 private 필드에 직접 접근하면 SyntaxError남 (JS 엔진 차원에서 막음)
    - 다만, TypeScript의 `private value: number` (샾(#) 없이)와는 다르게, **문법상 아예** `private value;` → `#value;` 자동 변환은 안 해 줌, TypeScript의 **`private`**(샾 없음)는 **컴파일 타임 전용** 검증, JavaScript 표준의 `#value`는 **런타임**에서도 실제 은닉이 보장됨

- 객체 리터럴을 직접 대입할 때와 변수로 대입할 때의 차이

  - TypeScript에서는 객체 리터럴(직접 `{}`로 만든 객체)을 인터페이스에 대입할 때, 정의된 프로퍼티와 정확히 일치해야 함
  - 다만, 이미 선언된 변수를 인터페이스 타입에 대입하면 _추가 프로퍼티 검사(Excess Property Check)_ 가 조금 관대해지거나 회피되는 경우가 있어 헷갈릴 수 있음.

    ```tsx
    interface Person {
      name: string;
      age: number;
    }

    // 객체 리터럴 직접 대입 -> 초과 프로퍼티 검사
    const p1: Person = {
      name: "Yeji",
      age: 25,
      // job: 'Developer', // 에러: Person 인터페이스에 없는 프로퍼티
    };

    // 변수에 먼저 담으면 초과 프로퍼티 검사 완화
    const someObj = { name: "Bob", age: 30, job: "Developer" };
    const p2: Person = someObj; // 에러가 안 날 수도 있음 (상황에 따라 다름)
    ```

  - TypeScript는 **직접 작성한 객체 리터럴**을 특정 인터페이스(혹은 타입)에 할당할 때, “이 객체가 정말 필요한 프로퍼티만 가지고 있는가?” “필요 이상의(=초과되는) 프로퍼티가 있지 않은가?”를 **엄격**하게 검사함. 이를 **“Excess Property Check”** 라고 부름
  - 반면 `someObj`는 `{ name, age, job }` 형태를 가진 **객체 리터럴**이지만, **이미 다른 변수**에 담겨 있음. 이 경우, **직접 리터럴**을 `p2: Person`으로 주는 것과는 다르게, TypeScript가 “`someObj`라는 **값**을 `Person` 타입에 할당할 수 있는가?”만 판단함. **추가 프로퍼티가 있더라도**, TypeScript가 “기본 구조적 타이핑(Structural Typing)”을 적용할 때, “필수 프로퍼티를 모두 가지고 있으면 할당 가능”이라고 보는 관대한 로직이 작동할 수 있음. 다만, TS 버전·컴파일러 옵션(`strict` 등)에 따라 경고 또는 에러가 날 수도 있으므로 “**대체로 초과 프로퍼티 체크가 완화된다**” 정도로 이해하면 됨
    - **_타입체커는 someObj을 Person타입에 할당할 수 있는가?를 일반적인 덕타이핑 (구조적 서브타이핑) 규칙에 따라 판정._**
    - **_타입체커: “Person이 필요로 하는 프로퍼티는 모두 존재하네? 그럼 오케이~”_**
    - 체커 단계에서의 실제 분기 (버전에 따라 달라질 수 있으나 대략 개념이 이러함)
      1. **객체 리터럴인지 식별**
         - 어떤 대입 상황에서 **할당원이 ‘객체 리터럴 노드’**인지, 혹은 **변수(식별자)인지** 먼저 파악.
         - 만약 **객체 리터럴** → “이것은 **fresh literal**이다”라는 플래그를 세팅
      2. **타입 호환성 검사**
         - “Fresh literal”이면, 대상 타입(예: `Person`)에서 요구하는 프로퍼티를 모두 만족하는지 검사 → 동시에 “정의되지 않은 프로퍼티가 추가로 있는지”도 검사.
         - “Fresh literal”일 때 초과 프로퍼티가 있다 → **오류** 발생.
         - 반면, “이미 변수에 담긴 값”이라면 fresh 상태가 아니므로, **구조적 호환**만 검사 → 초과 프로퍼티는 무시.
  - 위에서 살펴본 `스캐너/렉서 - 파서 - 바인더 - 체커 - 트랜스`파일의 시점으로 살펴보자.
    - 소스 코드를 문자 단위로 읽어 **토큰(token)**들의 리스트로 만듦
    - 토큰들을 이어붙여 AST를 구성
      - 예: `{ name: "Bob", age: 30, job: "Developer" }` → `ObjectLiteralExpression` 노드로 표현, 그 하위에 `PropertyAssignment("name", StringLiteral("Bob"))` 등으로 쭉 들어감
    - AST를 순회하며 **심볼(Symbol)**들을 수집, **스코프**를 구성
    - 인터페이스 `Person`이나 변수 `someObj`, `p2` 등의 선언이 “어떤 스코프에서 어떤 이름을 갖는가”가 등록
    - **_그리고 각 변수나 식에 대해 타입을 추론 및 확인, 여기서 “Excess Property Check” 로직이 발동, 직접 객체 리터럴을 할당할 때 vs 이미 선언된 변수를 할당할 때 어떻게 다른지 분기처리_**
    - 최종적으로 JS 코드를 생성 (트랜스파일)
  - 아니 그럼 왜!!!!! 왜 이렇게 설계되었나?
    - 오타 가능성 잡아내기
      - **직접 객체 리터럴**일 때는 **오타** 여부를 잡아내도록 TypeScript가 도와줌
    - **실제 코드 재사용의 유연성**
      - 이미 정의된 객체(변수) 안에 여러 속성이 있을 수 있는데, 그걸 부분적으로만 써도 괜찮을 때가 많음
      - “**구조적 타이핑**”을 쓰는 언어(예: TS)에서 “추가 속성이 있으면 할당이 불가능해진다”면 코드 재사용성이 떨어질 수 있음
      - TypeScript는 이를 “**직접 리터럴** vs **기존 객체**”로 구분해서, 필요한 부분만 엄격히 하고 나머지는 유연하게 함.
    - **파서**에서는 둘 다 `ObjectLiteralExpression` 노드를 만들지만, **체커**에서 “fresh literal” vs “식별자를 통한 할당” 여부를 분기 처리하여, “Excess Property Check”를 적용하거나 생략함.

### Freshness?

- 신선한 객체(freshness) 개념
  - TypeScript 내부에는 “신선한(fresh) 객체 리터럴 타입”이라는 개념이 있음
  - 직접 객체 리터럴을 작성하면, TS는 이 객체를 “아직 다른 변수 등에 할당되지 않고, 방금 막 작성된 리터럴”로 간주
  - 이 리터럴이 할당 대상에 정확히 들어맞는지 엄격하게 검사하자고 결정
  - 이러한 “엄격 검사”에서 추가 프로퍼티가 보이면 에러를 내는 것이 “Excess Property Check”의 핵심 로직
  - 즉, 직접 리터럴은 “의도적으로 인터페이스(타입)와 정확히 일치하도록 쓰였어야 한다”라고 가정하기 때문에, “그렇지 않으면(초과되는 프로퍼티가 있으면) 오타나 실수일 가능성이 높다!”고 판단하는 것

## 레퍼런스

- https://dev.to/smitterhane/private-class-fields-in-javascript-es2022-3b8
